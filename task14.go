package main

import (
	"fmt"
)

type Set struct { // структура, представляющая наше мн-во
	len   uint     // поле, отражающее кол-во элем-ов в мн-ве
	elems []string // пустой срез
}

// в методе addElement реализована логика, которая проверяет, что добавляемое в множество значение УЖЕ ЕСТЬ в множестве, и если это так, добавления не происходит
func (s *Set) addElement(elem string) { // в кач-ве получателя метода - указатель на значение Set, чтобы не добавить элемент в КОПИЮ
	if s.len == 0 { // если элементы в срез ещё не добавлялись,
		s.len++                         // увеличиваем len на 1
		s.elems = append(s.elems, elem) // дополняем поле elements новым элементом
	} else { // если же в срезе уже есть ХОТЯ БЫ ОДИН элемент (len != 0), значит УЖЕ есть возможность, что сейчас мы вставим строковое значение, ПОВТОРЯЮЩЕЕ предыдущее
		for _, v := range s.elems { // проводим проверку претендующего на вставку элемента на равенство КАЖДОМУ уже находящемуся в срезе элементу;
			if v == elem { // если он повторяет уже существующий, добавлять мы его НЕ БУДЕМ. произойдет просто возврат из ф-ции
				return
			}
		}
		s.len++                         // в противном случае инкрементируем счетчик (добавился +1 элемент)
		s.elems = append(s.elems, elem) // и, собственно, добавляем этот элемент
	}
}

func main() {
	var mySet Set
	var mySlice = []string{"cat", "cat", "dog", "cat", "tree"}

	for _, val := range mySlice { // циклом перебираем срез, вызывая для значения Set метод добавления элемента, передавая значение элемента среза на данной итерации
		mySet.addElement(val)
	}
	fmt.Println("Множество:", mySet.elems)
}

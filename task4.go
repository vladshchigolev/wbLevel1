package main

import (
	"fmt"
	"time"
)

type Worker struct {
	ID   int
	ch   chan string // канал, из которого воркер будет читать значения (наш воркер будет читать из канала типа "chan string")
	quit chan bool // канал, использующийся воркером для получения сигнала, означающего, что ему необходимо завершиться
}

func NewWorker(ch chan string, ID int) *Worker { // Конструктор воркера, принимающий КАНАЛ, из которого он будет осуществлять чтение и ID'шник; и возвращающий нам УКАЗАТЕЛЬ на вновь созданную структуру
	return &Worker{ // Создается с помощью литерала значение (экземпляр) типа Worker и возвращается указатель на него
		ID:   ID,
		ch:   ch,
		quit: make(chan bool), // создаётся небуферизованный канал, по которому будет отправляться сигнал, означающий необходимость завершения горутины
	}
}

// У экземпляра воркера можно вызвать 2 метода: start() и stop()
func (wr *Worker) Start() { // метод start заставляет воркера читать значения из канала, переданного ему при создании этого воркера (вызове конструктора ())
	fmt.Println("Starting worker #", wr.ID)
	for { // select case позволяет осуществлять реализацию мультиплексирования
		select { // Здесь горутина будет заблокирована, пока не выполнится один из блоков case (в нашем случае нет секции default)
		case val := <-wr.ch: // если есть что прочитать из канала, выполнится чтение из канала и запись в переменную val
			fmt.Println(val) // Вывод значения val в консоль
		case <-wr.quit: // этот case останется заблокированным до того момента, пока по каналу не будет отправлено сигнальное значение (остановка воркера)
			return // возврат из функции произойдёт только если на очередной итерации цикла разблокируется данный блок case
		}
	}
}

func (wr *Worker) Stop() { //
	fmt.Println("Stopping worker #", wr.ID)
	go func() { wr.quit <- true }() // Отправляется сигнал воркеру, означающий необходимость его завершения
}

func main() {
	arr := [20]string{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t"}

	ch := make(chan string, 10) // все создаваемые воркеры будут читать значения из ЭТОГО канала, main-горутина будет писать в него

	var workers []Worker // Объявляем слайс значений типа Worker. Пока он пуст. Набъем его значениями, чтобы потом можно было разом остановить всех воркеров (циклом)
	for i := 0; i < 3; i++ { // Заполняем слайс экземплярами (значениями) типа Worker (в нашем случае их 3), предварительно создаваемыми на каждой итерации цикла конструктором "NewWorker"
		worker := NewWorker(ch, i)
		//fmt.Println(worker)
		workers = append(workers, *worker) // Т. к. конструктор возвращает указатель на создаваемую структуру, необходимо разыменовать его перед добавлением в слайс значений типа Worker
		go worker.Start() // Вызываем у экземпляра метод Start(), который выполнится в новой горутине (асинхронно)
	}
	for _, v := range arr { // main последовательно пишет в канал значения из массива
		ch <- v
	}
	time.Sleep(3 * time.Second) // останавливаем main-горутину на некоторое время, чтобы воркеры получили возможность прочитать значения
	for i := 0; i < 3; i++ { // перебираем слайс workers, для каждого значения Worker вызывая метод Stop()
		workers[i].Stop() // Вызов Stop() для всех воркеров (каждый в новой горутине)
	}
}
package main

import (
	"fmt"
	"sync"
)

// есть 2 известных мне способа не дать main-горутине завершится, преждевременно убив вместе с собой все горутины, созданные ею.
// решение - заблокировать main-горутину, до тех пор, пока все остальные горутины не завершили свою работу
// в таком случае main-горутине необходимо дать знать, когда можно разблокироваться
// 1. Это можно сделать с помощью каналов: main-горутина заблокируется операцией чтения из канала, куда отправит сигнальное значение другая горутина, означающее, что она завершила работу
// после чего main-горутина будет разблокирована
// 2. Это можно сделать с помощью WaitGroup
// НЕВЕРНО
//
func main() {
	wg := sync.WaitGroup{}   // с помощью литерала создаем инстанс типа WaitGroup из пакета sync
	for i := 0; i < 5; i++ { // в цикле запускаются горутины
		wg.Add(1)                           // перед запуском каждой горутины инкрементируем счетчик (+1 работающая горутина)
		go func(wg sync.WaitGroup, i int) { // передаётся КОПИЯ экземпляра типа sync.WaitGroup, вместо указателя
			fmt.Println(i)
			wg.Done() // счетчик уменьшается на 1-цу у КОПИИ, не у оригинала
		}(wg, i)
	}
	wg.Wait() //Счетчик НИКОГДА не станет равным 0, main-горутина будет заблокирована навечно (deadlock)
	fmt.Println("exit")
}

//ВЕРНО
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

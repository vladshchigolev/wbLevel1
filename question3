Вообще, Мьютекс охраняет совместно используемые горутинами переменные. Каждый раз, когда горутина обращается к совместн. используемой переменной,
она должна вызвать метод Lock мьютекса, чтобы получить монопольную блокировку. (Если в этот момент переменную кто-то использует, операция БЛОКИРУЕТСЯ, пока этот кто-то не снимет блокировку)
Когда горутина завершила обращение к переменной - должна блокировку СНЯТЬ (вызвать Unlock()).
=============================================================================================================================================================================================
стоит упомянуть defer - он позволяет вызовы lock и unclock в коде держать рядом, при этом гарантируется,
что функция завершится вызовом unlock НА ВСЕХ ПУТЯХ ВЫПОЛНЕНИЯ (удобно, когда алгоритм ветвится). критический раздел будет расширен до конца текущей функции
==============================================================================================================================================================================================
Множественные параллельные вызовы функции/ий, которой/ым нужно ТОЛЬКО ЧИТАТЬ состояние переменной, будут БЕЗОПАСНЫМИ.
Поэтому RWMutex позволяет вызвать сколько угодно RLock() (писать нельзя будет пока последний RUnlock() не отработает)
А если вызвать у значения типа Mutex метод Lock(), то ни читать, ни писать охр. переменную нельзя, пока не вызовут Unlock()
В этом смысле операции над переменной можно разделить на оп. чтения и чтения\записи. Они взаимоисключающие
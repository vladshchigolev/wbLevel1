package main

import "fmt"

// Используем рекурсивный алгоритм
// Идея заключается в том, чтобы на каждом шаге поиска "отметать" часть массива, в которой искомого элемента НЕ МОЖЕТ БЫТЬ ПО ОПРЕДЕЛЕНИЮ.
// Вывод о том, что в определенном диапазоне отсутствует искомый элемент справедлив в том случае, если массив отсортирован по неубыванию (некоторые элементы могут иметь одинаковое значение,
// но это уже к вопросу о левом и правом бинарном поиске)
// на первом шаге поиска есть минимальный и максимальный индекс, и все элементы в этих границах (включительно) - наше поле поиска
func binarySearch(a []int, search int) (result int, searchCount int) { // вход: массив, значение искомого элемента; выход: индекс искомого элемента, какое кол-во шагов поиска выполнено
	mid := len(a) / 2 // ищем середину массива (индекс элемента посередине), mid всегда зависит от len(), а len() с каждым более глубоким уровнем рекурсии уменьшается
	switch {
	case len(a) == 0: // Во-первых, если массив пустой изначально, то там не может быть искомого элемента, во-вторых, если эл-та нет в НЕПУСТОМ массиве, по мере углубления в рекурсию
		// и "отрезания" кусочков от исходного массива, len() будет уменьшатся (сужаться поле поиска), пока не сузиться до len() == 0
		result = -1 // записываем в result "-1", что будет означать "элемент не найден", в рекурсию НЕ УХОДИМ
	// здесь описаны случаи, когда поле поиска ещё не сузилось до 0, но элемент ещё не найден
	// когда ещё сущ-ет диапазон, по которому можно искать, мы "тычем" в его "серединный" элемент и сравниваем ЕГО значение с ИСКОМЫМ значением
	// здесь может быть 3 варианта: 1. выбранный элемент совпадает с искомым - отрабатывает секция default; 2. выбранн. элем. БОЛЬШЕ искомого - значит всё, что находится справа, включая этот
	// выбранн. элем. - можно отсеять. Поэтому вызываем binarySearch с массивом, в котором осталась та часть, в которой ещё может быть искомый элемент.
	// может произойти оч много рекурсивных вызовов binarySearch, и когда отработает последняя (крайний случай), пойдёт обратный ход рекурсии, они начнут возвращать друг другу значения
	case a[mid] > search: // "тычем" в середину
		result, searchCount = binarySearch(a[:mid], search) // берем только левую часть предыдущего поля поиска (не включая mid), это будет НОВОЕ поле поиска
	case a[mid] < search:
		result, searchCount = binarySearch(a[mid+1:], search) // не включая mid, берем только правую часть предыдущего поля поиска, это будет НОВОЕ поле поиска
		if result >= 0 {                                      // if anything but the -1 "not found" result
			result += mid + 1 // т. к. result, возвращенный ф-цией на 24-ой строчке - это индекс искомого элемента в исходном массиве не соответствует индексу ТОГО ЖЕ элемента,
			// но только в переданном функции на 24-ой строчке отрезанном от того массиве, нам необходимо на основании возвращённого индекса восстановить индекс этого элемента в исходном массиве
			// это происходит ТОЛЬКО в случае с case a[mid] < search, в случае case a[mid] > search индексы элементов исходного и отрезанного массивов соответствуют друг другу
		}
	default: // a[mid] == search ()
		result = mid // found
	}
	searchCount++
	return // возвращаем result и значение searchCount
}

func main() {
	searchField := []int{2, 3, 7, 14, 16, 27, 39, 42, 59, 71} // массив отсортирован по НЕУБЫВАНИЮ (обязательное условие для работы бинарного поиска)
	fmt.Println(binarySearch(searchField, 16))
}

package main

import (
	"fmt"
	"sync"
)

func main() {
	arr := [...]int{2, 4, 6, 8, 10} // Объявляем массив целочисленных значений
	res := make(chan int, len(arr)) // Канал является ссылкой на структуру данных, создаваемую с помощью функции make
	// т. к. буфер канала у нас равен количеству элементов используемого массива, блокировки какой-либо из ОТПРАВЛЯЮЩИХ горутин (в связи с переполнением канала и, как следствие,
	// невозможностью дальнейшей отправки в него) не должно происходить В ПРИНЦИПЕ
	for _, val := range arr { // Сделаем перебор элементов массива (индекс опустим), и для каждого элемента
		go squarer(val, res)   // будет создана горутина, в которой запустится функция square()
	}						  // При вызове функции передаём ей копию элемента на текущей итерации цикла и канал (ссылку на структуру данных канала)
	for i := 1; i <= cap(res); i++ { // В цикле организовано чтение значений из канала и их вывод в консоль
		fmt.Println(<-res)          // Благодаря условию цикла, операций чтения из канала будет произведено ровно столько, сколько значений будет отправлено в канал (не больше, чем ёмкость канала)
	}								// В добавок горутина main не завершится прежде чем все воркеры не закончат свою работу
	fmt.Println("---------------")
	var wg sync.WaitGroup
	for _, v := range arr {
		wg.Add(1)
		go square2(v, &wg)
	}
	wg.Wait()

}

func squarer(origVal int, result chan int) { // 1-й параметр - то, что необходимо возвести в квадрат, 2-ой - канал, в который нужно произвести запись результата вычисления
	result <- origVal * origVal
}

func square2(x int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println(x * x)
}


package main

import (
	"fmt"
	"sync"
)

func main() {
	fmt.Println("------METHOD 1---------")
	arr := [...]int{2, 4, 6, 8, 10} // Объявляем массив целочисленных значений
	res := make(chan int, len(arr)) // Канал является ссылкой на структуру данных, создаваемую с помощью функции make
	// т. к. буфер канала у нас равен количеству элементов используемого массива, блокировки какой-либо из ОТПРАВЛЯЮЩИХ горутин (в связи с переполнением канала и, как следствие,
	// невозможностью дальнейшей отправки в него) не должно происходить В ПРИНЦИПЕ
	for _, val := range arr { // Сделаем перебор элементов массива (индекс опустим), и для каждого элемента
		go squarer(val, res) // будет создана горутина, в которой запустится функция square()
	} // При вызове функции передаём ей копию элемента на текущей итерации цикла и канал (ссылку на структуру данных канала)
	for i := 1; i <= cap(res); i++ { // В цикле организовано чтение значений из канала и их вывод в консоль
		fmt.Println(<-res) // Благодаря условию цикла, операций чтения из канала будет произведено ровно столько, сколько значений будет отправлено в канал (и не больше, чем ёмкость канала)
	} // В добавок горутина main не завершится прежде чем все воркеры не закончат свою работу
	fmt.Println("------METHOD 2---------") // Также избежать преждевременного завершения main-горутины можно спользовав sync.WaitGroup
	var wg sync.WaitGroup                  // Это структура со счетчиком, которая отслеживает сколько горутин было создано, и сколько из них было завершено
	for _, v := range arr {
		wg.Add(1)           // Счетчик не понимает автоматически, когда была запущена программа, поэтому нам нужно вручную инкрементировать его
		go squarer2(v, &wg) // при вызове ф-ции в новой горутине, передаем ей в кач-ве параметра указатель на экземпляр sync.WaitGroup
	}
	wg.Wait() // вызов метода блокирует main-горутину, до момента, пока счетчик, хранящий число запущенных горутин, не станет равным 0

}

func squarer(origVal int, result chan int) { // 1-й параметр - то, что необходимо возвести в квадрат, 2-ой - канал, в который нужно произвести запись результата вычисления
	result <- origVal * origVal
}

func squarer2(x int, wg *sync.WaitGroup) {
	defer wg.Done() // счетчик будет декрементирован перед выходом из функции
	fmt.Println(x * x)
}

package main

import "fmt"

func someAction(val []int8, b int8) { // срез - это reference type
	val[0] = 100 // Поскольку срез содержит указатель на элемент массива, передача среза в функцию
	// позволяет изменять элементы базового массива. Другими словами, копирование среза
	// создает ПСЕВДОНИМ для базового массива (val ссылается на ТОТ ЖЕ массив, что и slice)
	val = append(val, b) // в этот момент val начнет ссылаться на другой массив (размера старого нам не хватило для добавления элемента)
	fmt.Println("val inside func:", val)
	// Похоже, данный вызов функции append приводит к перераспределению памяти, поэтому результирующий срез, относится к другому массиву
	// мы НЕ СМОЖЕМ обратиться к массиву под val ВНЕ функции, только если не вернем val из функции
	// Поэтому мы и перезаписываем val при вызове append, потому что если val не перезаписать, val НЕ ИЗМЕНИТСЯ, также как и не изменилась slice
}

func main() {
	var slice = []int8{1, 2, 3, 4, 5}
	fmt.Println("capacity of slice var:", cap(slice)) // длина не может превышать ёмкость - в таком случае выделится НОВЫЙ массив
	fmt.Println(slice)
	someAction(slice, 6)
	fmt.Println(slice) // пытаемся вывести slice, думая что там будет ещё и 6-ой элемент,
	// но к этому моменту slice уже не связан с val, у val уже другой базовый массив
}

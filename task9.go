package main

import (
	"fmt"
)

func main() {

	arrElems := make(chan int)
	doubledVals := make(chan int)

	go func() {
		var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
		for _, val := range arr { // горутина последовательно отправляет значения из массива в канал, пока не переберет весь массив,
			arrElems <- val
		}
		close(arrElems) // после чего закрывает канал, чтобы сообщить, что дальнейшей передачи значений НЕ БУДЕТ, и бесполезно ждать получения на другой стороне
	}() // (делаем это во избежание deadlock'а)

	go func() {
		for {
			x, ok := <-arrElems
			if ok == false { // если горутина, от которой ЭТА горутина получает значения, закрыла свой канал,
				close(doubledVals) // ЭТА горутина, в свою очередь, закрывает СВОЙ канал (канал ей, кнчн, не принадлежит, он условно её, ОНА отправляет по нему значения)
				return
			}
			doubledVals <- 2 * x // в этом случае продолжаем отправлять 2x
		}
	}()

	for {
		result, ok := <-doubledVals // ok == true при успешном получении значения и false — при получении из закрытого И опустошенного (когда уже пошли нулевые значения) канала (если он буферизованный)
		if ok == false {            // Это условие обязательно! Иначе будем читать нулевые значения элементов из закрытого канала в бесконечном цикле
			break
		}
		fmt.Println(result)
	}

}
